<!DOCTYPE html>
<html>
<head>
    
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css"/>
    
            <meta name="viewport" content="width=device-width,
                initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
            <style>
                #map_3eacee0c8e82bfb830a4c2d2927ba22b {
                    position: relative;
                    width: 100.0%;
                    height: 100.0%;
                    left: 0.0%;
                    top: 0.0%;
                }
                .leaflet-container { font-size: 1rem; }
            </style>

            <style>html, body {
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            </style>

            <style>#map {
                position:absolute;
                top:0;
                bottom:0;
                right:0;
                left:0;
                }
            </style>

            <script>
                L_NO_TOUCH = false;
                L_DISABLE_3D = false;
            </script>

        
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.1.0/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.1.0/MarkerCluster.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.1.0/MarkerCluster.Default.css"/>
</head>
<body>
    
    
    <script>
    (function(){
        var dataUrl = 'all_regions_cities_map_optimized.data.json';
        var mapVar = 'map_3eacee0c8e82bfb830a4c2d2927ba22b';
        
        function getMap(){ return window[mapVar]; }
        
        fetch(dataUrl)
            .then(response => response.json())
            .then(data => {
                console.log('Loaded ' + data.length + ' cities');
                renderMarkers(data);
            })
            .catch(error => {
                console.error('Error loading data:', error);
                alert('Error loading map data. Please refresh the page.');
            });
        
        function renderMarkers(records) {
            var map = getMap();
            if (!map) {
                console.error('Map not ready');
                return;
            }
            
            // Create marker cluster
            var cluster = L.markerClusterGroup();
            
            // Create peaks layer
            var peaksGroup = L.featureGroup();
            var seenPeaks = {};
            
            records.forEach(function(r) {
                if (!r.latitude || !r.longitude) return;
                
                var lat = parseFloat(r.latitude);
                var lon = parseFloat(r.longitude);
                
                // Build popup
                var popup = buildPopup(r);
                
                // Determine color based on population
                var color = getMarkerColor(r.population);
                
                // Create marker
                var marker = L.circleMarker([lat, lon], {
                    radius: 6,
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.85,
                    population: parseInt(r.population) || 0,
                    driving_time_to_airport_minutes: r.driving_time_minutes_to_airport || '',
                    driving_time_to_hospital_minutes: r.driving_time_minutes_to_hospital || '',
                    hospital_in_city: r.hospital_in_city || '',
                    hospital_in_city_or_nearby: r.hospital_in_city_or_nearby || ''
                }).bindPopup(popup, {maxWidth: 350});
                
                cluster.addLayer(marker);
                
                // Add peaks if present
                if (r.peaks_higher1200_within30km && Array.isArray(r.peaks_higher1200_within30km)) {
                    r.peaks_higher1200_within30km.forEach(function(pk) {
                        var plat = parseFloat(pk.latitude);
                        var plon = parseFloat(pk.longitude);
                        var pname = pk.name || 'Peak';
                        var key = plat.toFixed(5) + ',' + plon.toFixed(5) + ',' + pname;
                        
                        if (seenPeaks[key]) return;
                        seenPeaks[key] = true;
                        
                        var elevStr = '';
                        if (pk.elevation) {
                            var m = parseFloat(pk.elevation);
                            var ft = Math.round(m * 3.28084);
                            elevStr = ' (' + Math.round(m) + ' m / ' + ft.toLocaleString() + ' ft)';
                        }
                        
                        L.circleMarker([plat, plon], {
                            radius: 4,
                            color: 'black',
                            fillColor: 'white',
                            fillOpacity: 0.9
                        }).bindPopup(pname + elevStr, {maxWidth: 220})
                          .addTo(peaksGroup);
                    });
                }
            });
            
            map.addLayer(cluster);
            peaksGroup.addTo(map);
            
            // Add layer control
            var overlays = {
                'Cities': cluster,
                'Peaks (≥1200m over city within 30km)': peaksGroup
            };
            L.control.layers(null, overlays, {collapsed: false}).addTo(map);
            
            // Fit bounds to data
            if (cluster.getLayers().length > 0) {
                map.fitBounds(cluster.getBounds(), {padding: [50, 50]});
            }
        }
        
        function getMarkerColor(population) {
            var pop = parseFloat(population) || 0;
            if (pop >= 100000) return 'darkred';
            if (pop >= 50000) return 'red';
            if (pop >= 20000) return 'orange';
            if (pop >= 10000) return 'green';
            return 'blue';
        }
        
        function buildPopup(r) {
            var parts = [];
            parts.push('<b>' + (r.name || 'Unknown') + '</b>');
            if (r.country) parts.push(' (' + r.country + ')');
            
            if (r.population) {
                parts.push('<br/>Population: ' + parseInt(r.population).toLocaleString());
            }
            
            if (r.elevation) {
                var m = parseFloat(r.elevation);
                var ft = Math.round(m * 3.28084);
                parts.push('<br/>Elevation: ' + Math.round(m) + ' m / ' + ft.toLocaleString() + ' ft');
            }
            
            if (r.airport_nearest_name) {
                parts.push('<br/>Nearest airport: ' + r.airport_nearest_name);
            }
            
            if (r.driving_time_minutes_to_airport) {
                parts.push('<br/>Drive to nearest airport: ' + Math.round(r.driving_time_minutes_to_airport) + ' min');
            }
            
            if (r.driving_time_minutes_to_hospital) {
                parts.push('<br/>Drive to nearest hospital: ' + Math.round(r.driving_time_minutes_to_hospital) + ' min');
            }
            
            if (r.hospital_nearest_name) {
                parts.push('<br/>Nearest hospital: ' + r.hospital_nearest_name);
            }
            
            if (r.peaks_higher1200_within30km_count) {
                parts.push('<br/>Higher peaks within 30 km (≥1200 m): ' + r.peaks_higher1200_within30km_count);
            }
            
            if (r.peaks_higher1200_within30km_names) {
                var names = r.peaks_higher1200_within30km_names;
                if (names.length > 140) names = names.substring(0, 137) + '...';
                parts.push('<br/>Peaks: ' + names);
            }
            
            if (r.source) {
                parts.push('<br/>Source: ' + r.source);
            }
            
            if (r.name && r.name.toLowerCase() !== 'unknown') {
                var q = encodeURIComponent(r.name);
                parts.push('<br/><a href="https://www.google.com/search?q=' + q + '" target="_blank" rel="noopener noreferrer">Search on Google</a>');
            }
            
            // Hidden metadata for filters
            parts.push('<span class="city-meta" style="display:none" ' +
                      'data-dta="' + (r.driving_time_minutes_to_airport || '') + '" ' +
                      'data-dth="' + (r.driving_time_minutes_to_hospital || '') + '" ' +
                      'data-hic="' + (r.hospital_in_city || '').toLowerCase() + '" ' +
                      'data-hcn="' + (r.hospital_in_city_or_nearby || '').toLowerCase() + '"></span>');
            
            return parts.join('');
        }
    })();
    </script>
    
    <script>
    (function(){
      var MAP_VAR_NAME = 'map_3eacee0c8e82bfb830a4c2d2927ba22b';
      function getMap(){ return window[MAP_VAR_NAME]; }

      function collectMarkers(layer, out){
        if (!layer) return;
        if (layer instanceof L.CircleMarker) {
          out.push(layer);
        } else if (layer.getLayers && typeof layer.getLayers === 'function') {
          var children = layer.getLayers();
          for (var i=0;i<children.length;i++) collectMarkers(children[i], out);
        } else if (layer.eachLayer && typeof layer.eachLayer === 'function') {
          layer.eachLayer(function(child){ collectMarkers(child, out); });
        }
      }

      function collectClusters(layer, out){
        if (!layer) return;
        if (typeof L.MarkerClusterGroup !== 'undefined' && (layer instanceof L.MarkerClusterGroup)) {
          out.push(layer);
        } else if (layer.getLayers && typeof layer.getLayers === 'function') {
          var children = layer.getLayers();
          for (var i=0;i<children.length;i++) collectClusters(children[i], out);
        } else if (layer.eachLayer && typeof layer.eachLayer === 'function') {
          layer.eachLayer(function(child){ collectClusters(child, out); });
        }
      }

      function readPopulation(marker){
        var p = 0;
        if (marker && marker.options && marker.options.population != null) {
          var n = Number(marker.options.population);
          if (!isNaN(n)) return n;
        }
        try {
          var pop = 0;
          var popup = marker.getPopup && marker.getPopup();
          var content = popup && (popup.getContent && popup.getContent());
          var htmlStr = '';
          if (typeof content === 'string') {
            htmlStr = content;
          } else if (content && typeof content.innerHTML === 'string') {
            htmlStr = content.innerHTML;
          } else if (content && typeof content.textContent === 'string') {
            htmlStr = content.textContent;
          }
          if (htmlStr) {
            var m = htmlStr.match(/Population:\s*([0-9,.]+)/i);
            if (m && m[1]) {
              pop = Number(m[1].replace(/[\,\s]/g, '')) || 0;
            }
          }
          return pop;
        } catch (e) { return 0; }
      }

      function readMeta(marker){
        try {
          var popup = marker.getPopup && marker.getPopup();
          var content = popup && (popup.getContent && popup.getContent());
          var root;
          if (typeof content === 'string') {
            var div = document.createElement('div');
            div.innerHTML = content;
            root = div;
          } else if (content && content instanceof HTMLElement) {
            root = content;
          } else if (content && content.innerHTML) {
            var d2 = document.createElement('div');
            d2.innerHTML = content.innerHTML;
            root = d2;
          }
          if (!root) return { dta:null, dth:null, hic:'', hcn:'' };
          var meta = root.querySelector('.city-meta');
          if (!meta) return { dta:null, dth:null, hic:'', hcn:'' };
          var dta = meta.getAttribute('data-dta');
          var dth = meta.getAttribute('data-dth');
          var hic = (meta.getAttribute('data-hic') || '').toLowerCase();
          var hcn = (meta.getAttribute('data-hcn') || '').toLowerCase();
          var dtaNum = (dta !== null && dta !== '') ? Number(dta) : null;
          var dthNum = (dth !== null && dth !== '') ? Number(dth) : null;
          if (isNaN(dtaNum)) dtaNum = null;
          if (isNaN(dthNum)) dthNum = null;
          return { dta: dtaNum, dth: dthNum, hic: hic, hcn: hcn };
        } catch (e) {
          return { dta:null, dth:null, hic:'', hcn:'' };
        }
      }

      var state = window.__popFilterState || { indexBuilt:false, markerToOwners:{}, markers:[], clusters:[] };
      function buildIndex(){
        var map = getMap();
        state.markers = [];
        state.clusters = [];
        map.eachLayer(function(l){ collectMarkers(l, state.markers); });
        map.eachLayer(function(l){ collectClusters(l, state.clusters); });
        state.markerToOwners = {};
        for (var i=0;i<state.markers.length;i++){
          var m = state.markers[i];
          var owners = [];
          for (var j=0;j<state.clusters.length;j++){
            var c = state.clusters[j];
            if (c.hasLayer && c.hasLayer(m)) owners.push(c);
          }
          state.markerToOwners[m._leaflet_id] = owners;
        }
        state.indexBuilt = true;
        window.__popFilterState = state;
      }

      function showMarker(m){
        var map = getMap();
        var owners = state.markerToOwners[m._leaflet_id] || [];
        if (owners.length > 0){
          for (var i=0;i<owners.length;i++){
            var c = owners[i];
            if (!c.hasLayer(m)) c.addLayer(m);
          }
        } else {
          if (!map.hasLayer(m)) map.addLayer(m);
        }
        if (m._icon) m._icon.style.display = '';
        if (m._path) m._path.style.display = '';
      }

      function hideMarker(m){
        var map = getMap();
        var owners = state.markerToOwners[m._leaflet_id] || [];
        if (owners.length > 0){
          for (var i=0;i<owners.length;i++){
            var c = owners[i];
            if (c.hasLayer(m)) c.removeLayer(m);
          }
        } else {
          if (map.hasLayer(m)) map.removeLayer(m);
        }
        if (m._icon) m._icon.style.display = 'none';
        if (m._path) m._path.style.display = 'none';
      }

      function applyFilter(minPop, maxAirportMins, maxHospitalMins, hospitalInCity, hospitalInCityNearby){
        if (!state.indexBuilt) buildIndex();
        for (var i=0;i<state.markers.length;i++){
          var m = state.markers[i];
          var p = readPopulation(m);
          var show = (p >= minPop);
          var meta = readMeta(m);
          if (show && maxAirportMins != null){
            if (meta.dta == null) { show = false; } else { show = show && (meta.dta <= maxAirportMins); }
          }
          if (show && maxHospitalMins != null){
            if (meta.dth == null) { show = false; } else { show = show && (meta.dth <= maxHospitalMins); }
          }
          if (show && hospitalInCity && hospitalInCity !== 'any'){
            show = show && (meta.hic === hospitalInCity);
          }
          if (show && hospitalInCityNearby && hospitalInCityNearby !== 'any'){
            show = show && (meta.hcn === hospitalInCityNearby);
          }
          if (show) showMarker(m); else hideMarker(m);
        }
      }

      function ensureUI(){
        // If control already present, skip
        if (document.getElementById('pop-filter')) return;
        var map = getMap();
        var ctrl = L.control({position: 'topleft'});
        ctrl.onAdd = function(map){
          var container = L.DomUtil.create('div');
          container.innerHTML = `
    <div id="pop-filter" style="background: white; padding: 8px 10px; border-radius: 4px; box-shadow: 0 1px 4px rgba(0,0,0,0.3); max-width: 260px;">
  <div style="font-size:12px; margin-bottom:6px;"><b>Filters</b></div>
  <div style="font-size:12px; margin-bottom:6px;">
    <label>Min population</label><br/>
    <input id="pop-threshold" type="number" min="0" step="1000" value="0" style="width:120px;"/>
  </div>
  <div style="font-size:12px; margin-bottom:6px;">
    <label>Max driving time to airport (min)</label><br/>
    <input id="max-airport-mins" type="number" min="0" step="5" placeholder="" style="width:120px;"/>
  </div>
  <div style="font-size:12px; margin-bottom:6px;">
    <label>Max driving time to hospital (min)</label><br/>
    <input id="max-hospital-mins" type="number" min="0" step="5" placeholder="" style="width:120px;"/>
  </div>
  <div style="font-size:12px; margin-bottom:6px;">
    <label>Hospital in city?</label><br/>
    <select id="hospital-in-city" style="width:140px;">
      <option value="any" selected>any</option>
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div style="font-size:12px; margin-bottom:8px;">
    <label>Hospital in city or nearby?</label><br/>
    <select id="hospital-in-city-or-nearby" style="width:140px;">
      <option value="any" selected>any</option>
      <option value="yes">yes</option>
      <option value="no">no</option>
    </select>
  </div>
  <div>
    <button id="apply-pop-filter" style="margin-right:6px;">Apply</button>
    <button id="reset-pop-filter">Reset</button>
  </div>
</div>
          `;
          L.DomEvent.disableClickPropagation(container);
          return container;
        };
        ctrl.addTo(map);
      }

      function hookUI(){
        ensureUI();
        var btn = document.getElementById('apply-pop-filter');
        var reset = document.getElementById('reset-pop-filter');
        var input = document.getElementById('pop-threshold');
        var maxA = document.getElementById('max-airport-mins');
        var maxH = document.getElementById('max-hospital-mins');
        var hic = document.getElementById('hospital-in-city');
        var hcn = document.getElementById('hospital-in-city-or-nearby');
        if (!btn || !input) return;
        btn.addEventListener('click', function(){
          var v = Number(input.value || 0) || 0;
          var a = (maxA && maxA.value !== '') ? (Number(maxA.value)) : null;
          var h = (maxH && maxH.value !== '') ? (Number(maxH.value)) : null;
          var ic = (hic && hic.value) ? hic.value : 'any';
          var cn = (hcn && hcn.value) ? hcn.value : 'any';
          applyFilter(v, a, h, ic, cn);
        });
        input.addEventListener('keypress', function(e){
          if (e.key === 'Enter') {
            var v = Number(input.value || 0) || 0;
            var a = (maxA && maxA.value !== '') ? (Number(maxA.value)) : null;
            var h = (maxH && maxH.value !== '') ? (Number(maxH.value)) : null;
            var ic = (hic && hic.value) ? hic.value : 'any';
            var cn = (hcn && hcn.value) ? hcn.value : 'any';
            applyFilter(v, a, h, ic, cn);
          }
        });
        if (reset){
          reset.addEventListener('click', function(){
            if (input) input.value = 0;
            if (maxA) maxA.value = '';
            if (maxH) maxH.value = '';
            if (hic) hic.value = 'any';
            if (hcn) hcn.value = 'any';
            applyFilter(0, null, null, 'any', 'any');
          });
        }
      }

      function whenMapReady(fn){
        if (getMap()) { fn(); return; }
        var tries = 0; var maxTries = 200; // ~10s
        var iv = setInterval(function(){
          if (getMap()){ clearInterval(iv); fn(); }
          else if (++tries >= maxTries){ clearInterval(iv); }
        }, 50);
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function(){ whenMapReady(hookUI); });
      } else {
        whenMapReady(hookUI);
      }
    })();
    </script>
    
            <div class="folium-map" id="map_3eacee0c8e82bfb830a4c2d2927ba22b" ></div>
        

    <div style="position: fixed; bottom: 0; left: 0; right: 0; background: rgba(255,255,255,0.95); 
                padding: 8px 15px; font-size: 11px; border-top: 1px solid #ccc; z-index: 9999;
                box-shadow: 0 -2px 4px rgba(0,0,0,0.1);">
        <strong>Data Sources:</strong> 
        City data © <a href="https://www.geonames.org/" target="_blank">GeoNames</a> (CC BY 4.0) | 
        Hospital data © <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap contributors</a> (ODbL) | 
        Elevation data: SRTM | 
        Airport data: <a href="https://ourairports.com/" target="_blank">OurAirports</a> (Public Domain) | 
        <a href="attribution.html" target="_blank">Full Attribution & Legal</a>
    </div>
    
</body>
<script>
    
    
            var map_3eacee0c8e82bfb830a4c2d2927ba22b = L.map(
                "map_3eacee0c8e82bfb830a4c2d2927ba22b",
                {
                    center: [46.5, 10.0],
                    crs: L.CRS.EPSG3857,
                    
  "zoom": 5,
  "zoomControl": true,
  "preferCanvas": false,


                }
            );
            L.control.scale().addTo(map_3eacee0c8e82bfb830a4c2d2927ba22b);

            

        
    
            var tile_layer_adcdc0583c0debe88d77a726e9398544 = L.tileLayer(
                "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
                {
  "minZoom": 0,
  "maxZoom": 18,
  "maxNativeZoom": 18,
  "noWrap": false,
  "attribution": "Map data: \u00a9 \u003ca href=\"https://www.openstreetmap.org/copyright\"\u003eOpenStreetMap\u003c/a\u003e contributors, \u003ca href=\"http://viewfinderpanoramas.org\"\u003eSRTM\u003c/a\u003e | Map style: \u00a9 \u003ca href=\"https://opentopomap.org\"\u003eOpenTopoMap\u003c/a\u003e (\u003ca href=\"https://creativecommons.org/licenses/by-sa/3.0/\"\u003eCC-BY-SA\u003c/a\u003e)",
  "subdomains": "abc",
  "detectRetina": false,
  "tms": false,
  "opacity": 1,
}

            );
        
    
            tile_layer_adcdc0583c0debe88d77a726e9398544.addTo(map_3eacee0c8e82bfb830a4c2d2927ba22b);
        
    
            var marker_cluster_585086738622c4a5123e57211294c9b0 = L.markerClusterGroup(
                {
}
            );
        
    
            marker_cluster_585086738622c4a5123e57211294c9b0.addTo(map_3eacee0c8e82bfb830a4c2d2927ba22b);
        
</script>
</html>